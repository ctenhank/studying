“Process” is well-defined; “job” and “task” are ambiguous.

Fundamentally a job/task is *what* work is done, while a process is *how* it is done, usually anthropomorphised as *who* does it. A job is an overall *unit of work*, and is *composed* of tasks. In practice usage is very inconsistent, and often “task” == “process”, though formally a process *performs* a task.

**Process** is a well-defined operating systems concept, as is **thread**: a [process](http://en.wikipedia.org/wiki/Process_(computing)) is an instance of a program that is being executed, and is the basic unit of *resources*: a process consists of or “owns” its image, execution context, memory, files, etc.; etymologically a process is the steps done by a process*or*. A process consists of one or more threads, which are the unit of scheduling, and consist of some subset of a process (possibly shared with other threads): execution context and perhaps more. Traditionally a thread is the unit of *execution* on a processor (a thread is “what is executing”), but with multi-core processors and [hardware threads](https://en.wikipedia.org/wiki/Hardware_thread), some scheduling is done even at the level of a single core. There are various kinds of processes and threads, and the exact definition varies between platforms.

**Job** and **task** are today vague, ambiguous terms, especially *task*. A “[job](https://en.wikipedia.org/wiki/Job_(computing))” often means a set of processes, while a “[task](https://en.wikipedia.org/wiki/Task_(computing))” may mean a process, a thread, a process or thread, or, distinctly, a unit of work *done by* a process or thread.

To give an idea how confused the naming is, [Windows Task Manager](https://en.wikipedia.org/wiki/Windows_Task_Manager) manages (running) *processes*, while [Windows Task Scheduler](https://en.wikipedia.org/wiki/Windows_Task_Scheduler) schedules *programs* to execute in future, what is traditionally known as a [job scheduler](https://en.wikipedia.org/wiki/Job_scheduler), and uses the `.job` extension!

The term “[job](https://en.wikipedia.org/wiki/Job_(computing))” traditionally means a “piece of work” (as opposed to “occupation”), and is used as such in manufacturing, in the phrase “[job production](https://en.wikipedia.org/wiki/Job_production)”, meaning “custom production”, where it is contrasted with [batch production](https://en.wikipedia.org/wiki/Batch_production) (many items at once, one step at a time) and [flow production](https://en.wikipedia.org/wiki/Flow_production) (many items at once, all steps at the same time, by item). Note that these distinctions have become blurred in computing, notably in the oxymoronic term “[batch job](https://en.wikipedia.org/wiki/Batch_job)”.

In computing, “job” originates in non-interactive processing on mainframes, notably in IBM’s [Job Control Language](https://en.wikipedia.org/wiki/Job_Control_Language) for the [DOS/360](https://en.wikipedia.org/wiki/DOS/360) and [OS/360](https://en.wikipedia.org/wiki/OS/360) of the mid-1960s, and formally means a “unit of work for an operating system”, which consists of *steps*, each of which is a *request* to execute a specific program. Early computers primarily did [batch processing](https://en.wikipedia.org/wiki/Batch_processing) (running the same program over many input data), like census or billing, and a standard type of one-off *job* was compiling a program from source, which could then process *batches* of data. Later *batch* came to be applied to all non-interactive computing, whether one-off or multiple items.

In Unix shells, a “[job](https://en.wikipedia.org/wiki/Job_control_(Unix))” is the shell’s representation for a [process group](https://en.wikipedia.org/wiki/Process_group) – a set of processes that can all be sent a signal – concretely a pipeline and its descendent processes; note that running a script starts a job, exactly as in mainframes. The job is not done until the processes complete, and a job can be stopped, resumed, or terminated, which corresponds to suspending, resuming, or terminating the processes. Thus while *formally* a job is distinct from the process group, this is a subtle distinction and thus people often use “job” to mean “set of processes”.

Traditional jobs (and batches) have finite input data and should complete processing, successfully or not. By contrast, when running a server, such as a web server, the input, such as a stream of requests, is unlimited (formally codata). This is analogous to flow production, and the process (or “job”) never completes, though it can be terminated or “canceled”. In a quip, “a server’s job is never done” (formally, exit status will be CANCELED, not COMPLETED/SUCCESS).

The term “step” makes sense for sequential computing – one step follows another – but once you have concurrent computing, you have a *set* of *tasks*, which do not necessarily run in a particular order, rather than a *sequence* of *steps*. The term “task” was popularized by OS/360, which featured “Multiprogramming with a Fixed number of Tasks (MFT)” and “Multiprogramming with a Variable number of Tasks (MVT)”, though in this case “task” was used synonymously with “process” or “thread”, as the basic task is “execute this program” (so the resulting process/thread performs the task), which is probably the source of the ambiguity.

Formally “[multitasking](https://en.wikipedia.org/wiki/Computer_multitasking)” means “working on multiple tasks concurrently”, but in practice means an operating system (or virtual machine, or runtime, or individual process) “running multiple processes/threads concurrently”.

A clear distinction between tasks as *work* and process/threads as how the work is *done* is given in a [task queue](https://en.wikipedia.org/wiki/Task_queue), as in this [diagram](https://commons.wikimedia.org/wiki/File:Thread_pool.svg) of a [thread pool](https://en.wikipedia.org/wiki/Thread_pool): there is a (big, potentially unlimited) queue of incoming tasks (pending), which are performed by a (small, often fixed) set of threads, each task being performed by a single thread, and each thread performing a single task at a time: the active tasks correspond to the active threads. Concretely, consider a multithreaded web server, where the tasks are “service this web page request”, and each thread fetches (from disk or memory) or renders the web page (say by a template or PHP), then returns the result.

As you can see from this last example, it is often useful to distinguish tasks from threads or processes, and in particular contexts “job” and “task” have specific meanings, though in general they are ambiguous.

Clearest is thus to avoid using “job” or “task” and instead refer to a “set of processes”, “process”, or “thread”, and for servers to refer to *requests* (or *queries*) rather than *tasks*.